// Code generated by protoc-gen-go. DO NOT EDIT.
// source: adacore.proto

package adacorepb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ResourceType - resource type
type ResourceType int32

const (
	// RT_PAGE - This is a page
	ResourceType_RT_PAGE ResourceType = 0
	// RT_OTHER - This is other resource
	ResourceType_RT_OTHER ResourceType = 1
)

var ResourceType_name = map[int32]string{
	0: "RT_PAGE",
	1: "RT_OTHER",
}
var ResourceType_value = map[string]int32{
	"RT_PAGE":  0,
	"RT_OTHER": 1,
}

func (x ResourceType) String() string {
	return proto.EnumName(ResourceType_name, int32(x))
}
func (ResourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{0}
}

// MarkdownData - markdown data
type MarkdownData struct {
	// strData - markdown string data
	StrData string `protobuf:"bytes,1,opt,name=strData,proto3" json:"strData,omitempty"`
	// binaryData - binary data map, it's like images
	BinaryData map[string][]byte `protobuf:"bytes,2,rep,name=binaryData,proto3" json:"binaryData,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// hashName - hashname
	HashName string `protobuf:"bytes,3,opt,name=hashName,proto3" json:"hashName,omitempty"`
	// templateName - template Name
	TemplateName string `protobuf:"bytes,10,opt,name=templateName,proto3" json:"templateName,omitempty"`
	// templateData - template data
	TemplateData string `protobuf:"bytes,11,opt,name=templateData,proto3" json:"templateData,omitempty"`
	// expireTime - expire time in seconds
	ExpireTime int32 `protobuf:"varint,100,opt,name=expireTime,proto3" json:"expireTime,omitempty"`
	// ctrlKey - Control keys are generated and managed by the client
	CtrlKey              int32    `protobuf:"varint,101,opt,name=ctrlKey,proto3" json:"ctrlKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkdownData) Reset()         { *m = MarkdownData{} }
func (m *MarkdownData) String() string { return proto.CompactTextString(m) }
func (*MarkdownData) ProtoMessage()    {}
func (*MarkdownData) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{0}
}
func (m *MarkdownData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkdownData.Unmarshal(m, b)
}
func (m *MarkdownData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkdownData.Marshal(b, m, deterministic)
}
func (dst *MarkdownData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkdownData.Merge(dst, src)
}
func (m *MarkdownData) XXX_Size() int {
	return xxx_messageInfo_MarkdownData.Size(m)
}
func (m *MarkdownData) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkdownData.DiscardUnknown(m)
}

var xxx_messageInfo_MarkdownData proto.InternalMessageInfo

func (m *MarkdownData) GetStrData() string {
	if m != nil {
		return m.StrData
	}
	return ""
}

func (m *MarkdownData) GetBinaryData() map[string][]byte {
	if m != nil {
		return m.BinaryData
	}
	return nil
}

func (m *MarkdownData) GetHashName() string {
	if m != nil {
		return m.HashName
	}
	return ""
}

func (m *MarkdownData) GetTemplateName() string {
	if m != nil {
		return m.TemplateName
	}
	return ""
}

func (m *MarkdownData) GetTemplateData() string {
	if m != nil {
		return m.TemplateData
	}
	return ""
}

func (m *MarkdownData) GetExpireTime() int32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *MarkdownData) GetCtrlKey() int32 {
	if m != nil {
		return m.CtrlKey
	}
	return 0
}

// MarkdownStream - markdown stream data
type MarkdownStream struct {
	// totalLength - If the message is too long, it will send data in multiple msg, this is the total length.
	TotalLength int32 `protobuf:"varint,1,opt,name=totalLength,proto3" json:"totalLength,omitempty"`
	// curStart - The starting point of the current data (in bytes).
	CurStart int32 `protobuf:"varint,2,opt,name=curStart,proto3" json:"curStart,omitempty"`
	// curLength - The length of the current data (in bytes).
	CurLength int32 `protobuf:"varint,3,opt,name=curLength,proto3" json:"curLength,omitempty"`
	// hashData - This is the hash of each paragraph.
	HashData string `protobuf:"bytes,4,opt,name=hashData,proto3" json:"hashData,omitempty"`
	// totalHashData - If multiple messages return data, this is the hash value of all data, only sent in the last message.
	TotalHashData string `protobuf:"bytes,5,opt,name=totalHashData,proto3" json:"totalHashData,omitempty"`
	// data - binary data
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// error - error string
	Error string `protobuf:"bytes,100,opt,name=error,proto3" json:"error,omitempty"`
	// markdownData - If the data does not exceed 4mb, this is the data that is directly available.
	MarkdownData *MarkdownData `protobuf:"bytes,200,opt,name=markdownData,proto3" json:"markdownData,omitempty"`
	// token - API token
	Token                string   `protobuf:"bytes,300,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkdownStream) Reset()         { *m = MarkdownStream{} }
func (m *MarkdownStream) String() string { return proto.CompactTextString(m) }
func (*MarkdownStream) ProtoMessage()    {}
func (*MarkdownStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{1}
}
func (m *MarkdownStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkdownStream.Unmarshal(m, b)
}
func (m *MarkdownStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkdownStream.Marshal(b, m, deterministic)
}
func (dst *MarkdownStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkdownStream.Merge(dst, src)
}
func (m *MarkdownStream) XXX_Size() int {
	return xxx_messageInfo_MarkdownStream.Size(m)
}
func (m *MarkdownStream) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkdownStream.DiscardUnknown(m)
}

var xxx_messageInfo_MarkdownStream proto.InternalMessageInfo

func (m *MarkdownStream) GetTotalLength() int32 {
	if m != nil {
		return m.TotalLength
	}
	return 0
}

func (m *MarkdownStream) GetCurStart() int32 {
	if m != nil {
		return m.CurStart
	}
	return 0
}

func (m *MarkdownStream) GetCurLength() int32 {
	if m != nil {
		return m.CurLength
	}
	return 0
}

func (m *MarkdownStream) GetHashData() string {
	if m != nil {
		return m.HashData
	}
	return ""
}

func (m *MarkdownStream) GetTotalHashData() string {
	if m != nil {
		return m.TotalHashData
	}
	return ""
}

func (m *MarkdownStream) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MarkdownStream) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MarkdownStream) GetMarkdownData() *MarkdownData {
	if m != nil {
		return m.MarkdownData
	}
	return nil
}

func (m *MarkdownStream) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// ResourceInfo - resource infomation
type ResourceInfo struct {
	// hashName - hashname
	HashName string `protobuf:"bytes,1,opt,name=hashName,proto3" json:"hashName,omitempty"`
	// citedTimes - cited times
	CitedTimes int32 `protobuf:"varint,2,opt,name=citedTimes,proto3" json:"citedTimes,omitempty"`
	// createTime - Creation time in seconds
	CreateTime int64 `protobuf:"varint,3,opt,name=createTime,proto3" json:"createTime,omitempty"`
	// type - resource type
	Type ResourceType `protobuf:"varint,4,opt,name=type,proto3,enum=adacorepb.ResourceType" json:"type,omitempty"`
	// children - children resource hashname
	Children []string `protobuf:"bytes,10,rep,name=children,proto3" json:"children,omitempty"`
	// expireTime - expire time in seconds
	ExpireTime int32 `protobuf:"varint,100,opt,name=expireTime,proto3" json:"expireTime,omitempty"`
	// ctrlKey - Control keys are generated and managed by the client
	CtrlKey              int32    `protobuf:"varint,101,opt,name=ctrlKey,proto3" json:"ctrlKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceInfo) Reset()         { *m = ResourceInfo{} }
func (m *ResourceInfo) String() string { return proto.CompactTextString(m) }
func (*ResourceInfo) ProtoMessage()    {}
func (*ResourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{2}
}
func (m *ResourceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceInfo.Unmarshal(m, b)
}
func (m *ResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceInfo.Marshal(b, m, deterministic)
}
func (dst *ResourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceInfo.Merge(dst, src)
}
func (m *ResourceInfo) XXX_Size() int {
	return xxx_messageInfo_ResourceInfo.Size(m)
}
func (m *ResourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceInfo proto.InternalMessageInfo

func (m *ResourceInfo) GetHashName() string {
	if m != nil {
		return m.HashName
	}
	return ""
}

func (m *ResourceInfo) GetCitedTimes() int32 {
	if m != nil {
		return m.CitedTimes
	}
	return 0
}

func (m *ResourceInfo) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *ResourceInfo) GetType() ResourceType {
	if m != nil {
		return m.Type
	}
	return ResourceType_RT_PAGE
}

func (m *ResourceInfo) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *ResourceInfo) GetExpireTime() int32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *ResourceInfo) GetCtrlKey() int32 {
	if m != nil {
		return m.CtrlKey
	}
	return 0
}

// ReplyMarkdown - reply
type ReplyMarkdown struct {
	// url - url
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// hashName - hashname
	HashName string `protobuf:"bytes,2,opt,name=hashName,proto3" json:"hashName,omitempty"`
	// lstRes - resource list
	LstRes []*ResourceInfo `protobuf:"bytes,10,rep,name=lstRes,proto3" json:"lstRes,omitempty"`
	// err - error
	Err                  string   `protobuf:"bytes,100,opt,name=err,proto3" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyMarkdown) Reset()         { *m = ReplyMarkdown{} }
func (m *ReplyMarkdown) String() string { return proto.CompactTextString(m) }
func (*ReplyMarkdown) ProtoMessage()    {}
func (*ReplyMarkdown) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{3}
}
func (m *ReplyMarkdown) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReplyMarkdown.Unmarshal(m, b)
}
func (m *ReplyMarkdown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReplyMarkdown.Marshal(b, m, deterministic)
}
func (dst *ReplyMarkdown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyMarkdown.Merge(dst, src)
}
func (m *ReplyMarkdown) XXX_Size() int {
	return xxx_messageInfo_ReplyMarkdown.Size(m)
}
func (m *ReplyMarkdown) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyMarkdown.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyMarkdown proto.InternalMessageInfo

func (m *ReplyMarkdown) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ReplyMarkdown) GetHashName() string {
	if m != nil {
		return m.HashName
	}
	return ""
}

func (m *ReplyMarkdown) GetLstRes() []*ResourceInfo {
	if m != nil {
		return m.LstRes
	}
	return nil
}

func (m *ReplyMarkdown) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

// RoleInfo - role infomation
type TokenInfo struct {
	// token - token
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// maxExpireTime - max expire time in seconds
	MaxExpireTime int32 `protobuf:"varint,2,opt,name=maxExpireTime,proto3" json:"maxExpireTime,omitempty"`
	// isAllowTemplateData - Whether to allow templatedata
	IsAllowTemplateData bool `protobuf:"varint,3,opt,name=isAllowTemplateData,proto3" json:"isAllowTemplateData,omitempty"`
	// templates - This is all the templates available for this role.
	Templates []string `protobuf:"bytes,4,rep,name=templates,proto3" json:"templates,omitempty"`
	// resNums - This is the amount of resources available for this role
	ResNums              int32    `protobuf:"varint,5,opt,name=resNums,proto3" json:"resNums,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenInfo) Reset()         { *m = TokenInfo{} }
func (m *TokenInfo) String() string { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()    {}
func (*TokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_3bc6b05c10c0e32b, []int{4}
}
func (m *TokenInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenInfo.Unmarshal(m, b)
}
func (m *TokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenInfo.Marshal(b, m, deterministic)
}
func (dst *TokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenInfo.Merge(dst, src)
}
func (m *TokenInfo) XXX_Size() int {
	return xxx_messageInfo_TokenInfo.Size(m)
}
func (m *TokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenInfo proto.InternalMessageInfo

func (m *TokenInfo) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *TokenInfo) GetMaxExpireTime() int32 {
	if m != nil {
		return m.MaxExpireTime
	}
	return 0
}

func (m *TokenInfo) GetIsAllowTemplateData() bool {
	if m != nil {
		return m.IsAllowTemplateData
	}
	return false
}

func (m *TokenInfo) GetTemplates() []string {
	if m != nil {
		return m.Templates
	}
	return nil
}

func (m *TokenInfo) GetResNums() int32 {
	if m != nil {
		return m.ResNums
	}
	return 0
}

func init() {
	proto.RegisterType((*MarkdownData)(nil), "adacorepb.MarkdownData")
	proto.RegisterMapType((map[string][]byte)(nil), "adacorepb.MarkdownData.BinaryDataEntry")
	proto.RegisterType((*MarkdownStream)(nil), "adacorepb.MarkdownStream")
	proto.RegisterType((*ResourceInfo)(nil), "adacorepb.ResourceInfo")
	proto.RegisterType((*ReplyMarkdown)(nil), "adacorepb.ReplyMarkdown")
	proto.RegisterType((*TokenInfo)(nil), "adacorepb.TokenInfo")
	proto.RegisterEnum("adacorepb.ResourceType", ResourceType_name, ResourceType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AdaCoreServiceClient is the client API for AdaCoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdaCoreServiceClient interface {
	// buildWithMarkdown - build with markdown
	BuildWithMarkdown(ctx context.Context, opts ...grpc.CallOption) (AdaCoreService_BuildWithMarkdownClient, error)
}

type adaCoreServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdaCoreServiceClient(cc *grpc.ClientConn) AdaCoreServiceClient {
	return &adaCoreServiceClient{cc}
}

func (c *adaCoreServiceClient) BuildWithMarkdown(ctx context.Context, opts ...grpc.CallOption) (AdaCoreService_BuildWithMarkdownClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AdaCoreService_serviceDesc.Streams[0], "/adacorepb.AdaCoreService/buildWithMarkdown", opts...)
	if err != nil {
		return nil, err
	}
	x := &adaCoreServiceBuildWithMarkdownClient{stream}
	return x, nil
}

type AdaCoreService_BuildWithMarkdownClient interface {
	Send(*MarkdownStream) error
	CloseAndRecv() (*ReplyMarkdown, error)
	grpc.ClientStream
}

type adaCoreServiceBuildWithMarkdownClient struct {
	grpc.ClientStream
}

func (x *adaCoreServiceBuildWithMarkdownClient) Send(m *MarkdownStream) error {
	return x.ClientStream.SendMsg(m)
}

func (x *adaCoreServiceBuildWithMarkdownClient) CloseAndRecv() (*ReplyMarkdown, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReplyMarkdown)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AdaCoreServiceServer is the server API for AdaCoreService service.
type AdaCoreServiceServer interface {
	// buildWithMarkdown - build with markdown
	BuildWithMarkdown(AdaCoreService_BuildWithMarkdownServer) error
}

func RegisterAdaCoreServiceServer(s *grpc.Server, srv AdaCoreServiceServer) {
	s.RegisterService(&_AdaCoreService_serviceDesc, srv)
}

func _AdaCoreService_BuildWithMarkdown_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdaCoreServiceServer).BuildWithMarkdown(&adaCoreServiceBuildWithMarkdownServer{stream})
}

type AdaCoreService_BuildWithMarkdownServer interface {
	SendAndClose(*ReplyMarkdown) error
	Recv() (*MarkdownStream, error)
	grpc.ServerStream
}

type adaCoreServiceBuildWithMarkdownServer struct {
	grpc.ServerStream
}

func (x *adaCoreServiceBuildWithMarkdownServer) SendAndClose(m *ReplyMarkdown) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adaCoreServiceBuildWithMarkdownServer) Recv() (*MarkdownStream, error) {
	m := new(MarkdownStream)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AdaCoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "adacorepb.AdaCoreService",
	HandlerType: (*AdaCoreServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "buildWithMarkdown",
			Handler:       _AdaCoreService_BuildWithMarkdown_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "adacore.proto",
}

func init() { proto.RegisterFile("adacore.proto", fileDescriptor_adacore_3bc6b05c10c0e32b) }

var fileDescriptor_adacore_3bc6b05c10c0e32b = []byte{
	// 645 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xc7, 0x6b, 0x27, 0x6e, 0x9b, 0x49, 0xda, 0x5f, 0x7f, 0x4b, 0x11, 0xa6, 0x42, 0x55, 0x64,
	0x21, 0x11, 0x40, 0x0a, 0xa8, 0x5c, 0x10, 0x82, 0x43, 0x81, 0xa8, 0x45, 0x94, 0x82, 0xb6, 0x96,
	0xb8, 0x51, 0x6d, 0xec, 0x81, 0x58, 0xf5, 0x3f, 0xad, 0xd7, 0x6d, 0x7d, 0xe3, 0x81, 0xe0, 0xc0,
	0x5b, 0x70, 0xe2, 0x4d, 0x78, 0x07, 0xb4, 0xe3, 0x6c, 0x62, 0x57, 0xe5, 0xc2, 0x6d, 0xe7, 0x8f,
	0x67, 0x67, 0x3e, 0xf3, 0x5d, 0xc3, 0x86, 0x08, 0x45, 0x90, 0x49, 0x1c, 0xe7, 0x32, 0x53, 0x19,
	0xeb, 0xcd, 0xcd, 0x7c, 0xea, 0xfd, 0xb2, 0x61, 0xf0, 0x4e, 0xc8, 0xb3, 0x30, 0xbb, 0x48, 0x5f,
	0x0b, 0x25, 0x98, 0x0b, 0x6b, 0x85, 0x92, 0xfa, 0xe8, 0x5a, 0x43, 0x6b, 0xd4, 0xe3, 0xc6, 0x64,
	0x07, 0x00, 0xd3, 0x28, 0x15, 0xb2, 0xa2, 0xa0, 0x3d, 0xec, 0x8c, 0xfa, 0x7b, 0xf7, 0xc6, 0x8b,
	0x52, 0xe3, 0x66, 0x99, 0xf1, 0xcb, 0x45, 0xe6, 0x24, 0x55, 0xb2, 0xe2, 0x8d, 0x4f, 0xd9, 0x0e,
	0xac, 0xcf, 0x44, 0x31, 0x3b, 0x16, 0x09, 0xba, 0x1d, 0xba, 0x63, 0x61, 0x33, 0x0f, 0x06, 0x0a,
	0x93, 0x3c, 0x16, 0x0a, 0x29, 0x0e, 0x14, 0x6f, 0xf9, 0x9a, 0x39, 0xd4, 0x4a, 0xbf, 0x9d, 0x43,
	0x77, 0xec, 0x02, 0xe0, 0x65, 0x1e, 0x49, 0xf4, 0xa3, 0x04, 0xdd, 0x70, 0x68, 0x8d, 0x1c, 0xde,
	0xf0, 0xe8, 0x31, 0x03, 0x25, 0xe3, 0xb7, 0x58, 0xb9, 0x48, 0x41, 0x63, 0xee, 0xbc, 0x80, 0xff,
	0xae, 0x34, 0xcf, 0xb6, 0xa0, 0x73, 0x86, 0xd5, 0x9c, 0x87, 0x3e, 0xb2, 0x6d, 0x70, 0xce, 0x45,
	0x5c, 0xa2, 0x6b, 0x0f, 0xad, 0xd1, 0x80, 0xd7, 0xc6, 0x33, 0xfb, 0xa9, 0xe5, 0x7d, 0xb7, 0x61,
	0xd3, 0x90, 0x38, 0x51, 0x12, 0x45, 0xc2, 0x86, 0xd0, 0x57, 0x99, 0x12, 0xf1, 0x11, 0xa6, 0x5f,
	0xd4, 0x8c, 0xca, 0x38, 0xbc, 0xe9, 0xd2, 0x44, 0x82, 0x52, 0x9e, 0x28, 0x21, 0x15, 0x55, 0x74,
	0xf8, 0xc2, 0x66, 0x77, 0xa0, 0x17, 0x94, 0x72, 0xfe, 0x6d, 0x87, 0x82, 0x4b, 0x87, 0x61, 0x49,
	0x1c, 0xba, 0x4b, 0x96, 0xc4, 0xe0, 0x2e, 0x6c, 0xd0, 0x25, 0x87, 0x26, 0xc1, 0xa1, 0x84, 0xb6,
	0x93, 0x31, 0xe8, 0x86, 0x3a, 0xb8, 0x4a, 0x93, 0xd0, 0x59, 0x8f, 0x87, 0x52, 0x66, 0x92, 0xc0,
	0xf5, 0x78, 0x6d, 0xb0, 0xe7, 0x30, 0x48, 0x1a, 0x3b, 0x76, 0x7f, 0xea, 0x49, 0xfa, 0x7b, 0xb7,
	0xfe, 0xa2, 0x01, 0xde, 0xca, 0x66, 0x37, 0xc1, 0x51, 0xd9, 0x19, 0xa6, 0xee, 0x37, 0xbb, 0x2e,
	0x4a, 0x96, 0xf7, 0xdb, 0x82, 0x01, 0xc7, 0x22, 0x2b, 0x65, 0x80, 0x6f, 0xd2, 0xcf, 0x59, 0x4b,
	0x1d, 0xd6, 0x15, 0x75, 0xec, 0x02, 0x04, 0x91, 0xc2, 0x50, 0xaf, 0xb0, 0x98, 0x93, 0x6a, 0x78,
	0x28, 0x2e, 0x51, 0xa8, 0x7a, 0xeb, 0x1a, 0x56, 0x87, 0x37, 0x3c, 0xec, 0x21, 0x74, 0x55, 0x95,
	0x23, 0x91, 0xda, 0x6c, 0x35, 0x6e, 0x5a, 0xf0, 0xab, 0x1c, 0x39, 0x25, 0xd1, 0x52, 0x66, 0x51,
	0x1c, 0x4a, 0x4c, 0x5d, 0x18, 0x76, 0x74, 0x23, 0xc6, 0xfe, 0x77, 0x79, 0x79, 0x5f, 0x2d, 0xd8,
	0xe0, 0x98, 0xc7, 0x95, 0x41, 0xa5, 0xd5, 0x55, 0xca, 0xd8, 0xa8, 0xab, 0x94, 0x71, 0x0b, 0x81,
	0x7d, 0x05, 0xc1, 0x23, 0x58, 0x8d, 0x0b, 0xc5, 0xb1, 0xa0, 0x9e, 0xfa, 0xd7, 0x0e, 0xa1, 0x39,
	0xf2, 0x79, 0x9a, 0x2e, 0x8f, 0xd2, 0x6c, 0x52, 0x1f, 0xbd, 0x1f, 0x16, 0xf4, 0x7c, 0x0d, 0x9f,
	0x78, 0x6f, 0x9b, 0xbd, 0x58, 0x8d, 0xb5, 0x68, 0xed, 0x24, 0xe2, 0x72, 0xb2, 0x9c, 0xb1, 0x86,
	0xdd, 0x76, 0xb2, 0xc7, 0x70, 0x23, 0x2a, 0xf6, 0xe3, 0x38, 0xbb, 0xf0, 0x9b, 0x0f, 0x52, 0x83,
	0x5f, 0xe7, 0xd7, 0x85, 0xb4, 0x9a, 0xcd, 0x3b, 0x2d, 0xdc, 0x2e, 0x51, 0x5d, 0x3a, 0x34, 0x36,
	0x89, 0xc5, 0x71, 0x99, 0x14, 0xa4, 0x55, 0x87, 0x1b, 0xf3, 0xc1, 0xfd, 0xa5, 0x4a, 0xf4, 0x8a,
	0x58, 0x1f, 0xd6, 0xb8, 0x7f, 0xfa, 0x61, 0xff, 0x60, 0xb2, 0xb5, 0xc2, 0x06, 0xb0, 0xce, 0xfd,
	0xd3, 0xf7, 0xfe, 0xe1, 0x84, 0x6f, 0x59, 0x7b, 0x9f, 0x60, 0x73, 0x3f, 0x14, 0xaf, 0x32, 0x89,
	0x27, 0x28, 0xcf, 0xa3, 0x00, 0xd9, 0x11, 0xfc, 0x3f, 0x2d, 0xa3, 0x38, 0xfc, 0x18, 0xa9, 0xd9,
	0x02, 0xfb, 0xed, 0x6b, 0x64, 0x5b, 0x3f, 0xd8, 0x1d, 0xb7, 0xc5, 0xb4, 0xb1, 0x2b, 0x6f, 0x65,
	0x64, 0x4d, 0x57, 0xe9, 0x27, 0xfa, 0xe4, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x87, 0x70,
	0x08, 0x55, 0x05, 0x00, 0x00,
}
