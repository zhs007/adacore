// Code generated by protoc-gen-go. DO NOT EDIT.
// source: adacore.proto

package adacorepb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// MarkdownData - markdown data
type MarkdownData struct {
	// strData - markdown string data
	StrData string `protobuf:"bytes,1,opt,name=strData,proto3" json:"strData,omitempty"`
	// binaryData - binary data map, it's like images
	BinaryData map[string][]byte `protobuf:"bytes,2,rep,name=binaryData,proto3" json:"binaryData,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// templateName - template Name
	TemplateName string `protobuf:"bytes,10,opt,name=templateName,proto3" json:"templateName,omitempty"`
	// templateData - template data
	TemplateData         string   `protobuf:"bytes,11,opt,name=templateData,proto3" json:"templateData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkdownData) Reset()         { *m = MarkdownData{} }
func (m *MarkdownData) String() string { return proto.CompactTextString(m) }
func (*MarkdownData) ProtoMessage()    {}
func (*MarkdownData) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_329eb421bb8e5878, []int{0}
}
func (m *MarkdownData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkdownData.Unmarshal(m, b)
}
func (m *MarkdownData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkdownData.Marshal(b, m, deterministic)
}
func (dst *MarkdownData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkdownData.Merge(dst, src)
}
func (m *MarkdownData) XXX_Size() int {
	return xxx_messageInfo_MarkdownData.Size(m)
}
func (m *MarkdownData) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkdownData.DiscardUnknown(m)
}

var xxx_messageInfo_MarkdownData proto.InternalMessageInfo

func (m *MarkdownData) GetStrData() string {
	if m != nil {
		return m.StrData
	}
	return ""
}

func (m *MarkdownData) GetBinaryData() map[string][]byte {
	if m != nil {
		return m.BinaryData
	}
	return nil
}

func (m *MarkdownData) GetTemplateName() string {
	if m != nil {
		return m.TemplateName
	}
	return ""
}

func (m *MarkdownData) GetTemplateData() string {
	if m != nil {
		return m.TemplateData
	}
	return ""
}

// MarkdownStream - markdown stream data
type MarkdownStream struct {
	// totalLength - If the message is too long, it will send data in multiple msg, this is the total length.
	TotalLength int32 `protobuf:"varint,1,opt,name=totalLength,proto3" json:"totalLength,omitempty"`
	// curStart - The starting point of the current data (in bytes).
	CurStart int32 `protobuf:"varint,2,opt,name=curStart,proto3" json:"curStart,omitempty"`
	// curLength - The length of the current data (in bytes).
	CurLength int32 `protobuf:"varint,3,opt,name=curLength,proto3" json:"curLength,omitempty"`
	// hashData - This is the hash of each paragraph.
	HashData string `protobuf:"bytes,4,opt,name=hashData,proto3" json:"hashData,omitempty"`
	// totalHashData - If multiple messages return data, this is the hash value of all data, only sent in the last message.
	TotalHashData string `protobuf:"bytes,5,opt,name=totalHashData,proto3" json:"totalHashData,omitempty"`
	// data - binary data
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// error - error string
	Error string `protobuf:"bytes,100,opt,name=error,proto3" json:"error,omitempty"`
	// markdownData - If the data does not exceed 4mb, this is the data that is directly available.
	MarkdownData *MarkdownData `protobuf:"bytes,200,opt,name=markdownData,proto3" json:"markdownData,omitempty"`
	// token - API token
	Token                string   `protobuf:"bytes,300,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkdownStream) Reset()         { *m = MarkdownStream{} }
func (m *MarkdownStream) String() string { return proto.CompactTextString(m) }
func (*MarkdownStream) ProtoMessage()    {}
func (*MarkdownStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_329eb421bb8e5878, []int{1}
}
func (m *MarkdownStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkdownStream.Unmarshal(m, b)
}
func (m *MarkdownStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkdownStream.Marshal(b, m, deterministic)
}
func (dst *MarkdownStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkdownStream.Merge(dst, src)
}
func (m *MarkdownStream) XXX_Size() int {
	return xxx_messageInfo_MarkdownStream.Size(m)
}
func (m *MarkdownStream) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkdownStream.DiscardUnknown(m)
}

var xxx_messageInfo_MarkdownStream proto.InternalMessageInfo

func (m *MarkdownStream) GetTotalLength() int32 {
	if m != nil {
		return m.TotalLength
	}
	return 0
}

func (m *MarkdownStream) GetCurStart() int32 {
	if m != nil {
		return m.CurStart
	}
	return 0
}

func (m *MarkdownStream) GetCurLength() int32 {
	if m != nil {
		return m.CurLength
	}
	return 0
}

func (m *MarkdownStream) GetHashData() string {
	if m != nil {
		return m.HashData
	}
	return ""
}

func (m *MarkdownStream) GetTotalHashData() string {
	if m != nil {
		return m.TotalHashData
	}
	return ""
}

func (m *MarkdownStream) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MarkdownStream) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MarkdownStream) GetMarkdownData() *MarkdownData {
	if m != nil {
		return m.MarkdownData
	}
	return nil
}

func (m *MarkdownStream) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// ReplyMarkdown - reply
type ReplyMarkdown struct {
	// url - url
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyMarkdown) Reset()         { *m = ReplyMarkdown{} }
func (m *ReplyMarkdown) String() string { return proto.CompactTextString(m) }
func (*ReplyMarkdown) ProtoMessage()    {}
func (*ReplyMarkdown) Descriptor() ([]byte, []int) {
	return fileDescriptor_adacore_329eb421bb8e5878, []int{2}
}
func (m *ReplyMarkdown) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReplyMarkdown.Unmarshal(m, b)
}
func (m *ReplyMarkdown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReplyMarkdown.Marshal(b, m, deterministic)
}
func (dst *ReplyMarkdown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyMarkdown.Merge(dst, src)
}
func (m *ReplyMarkdown) XXX_Size() int {
	return xxx_messageInfo_ReplyMarkdown.Size(m)
}
func (m *ReplyMarkdown) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyMarkdown.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyMarkdown proto.InternalMessageInfo

func (m *ReplyMarkdown) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterType((*MarkdownData)(nil), "adacorepb.MarkdownData")
	proto.RegisterMapType((map[string][]byte)(nil), "adacorepb.MarkdownData.BinaryDataEntry")
	proto.RegisterType((*MarkdownStream)(nil), "adacorepb.MarkdownStream")
	proto.RegisterType((*ReplyMarkdown)(nil), "adacorepb.ReplyMarkdown")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AdaCoreServiceClient is the client API for AdaCoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdaCoreServiceClient interface {
	// buildWithMarkdown - build with markdown
	BuildWithMarkdown(ctx context.Context, opts ...grpc.CallOption) (AdaCoreService_BuildWithMarkdownClient, error)
}

type adaCoreServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdaCoreServiceClient(cc *grpc.ClientConn) AdaCoreServiceClient {
	return &adaCoreServiceClient{cc}
}

func (c *adaCoreServiceClient) BuildWithMarkdown(ctx context.Context, opts ...grpc.CallOption) (AdaCoreService_BuildWithMarkdownClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AdaCoreService_serviceDesc.Streams[0], "/adacorepb.AdaCoreService/buildWithMarkdown", opts...)
	if err != nil {
		return nil, err
	}
	x := &adaCoreServiceBuildWithMarkdownClient{stream}
	return x, nil
}

type AdaCoreService_BuildWithMarkdownClient interface {
	Send(*MarkdownStream) error
	CloseAndRecv() (*ReplyMarkdown, error)
	grpc.ClientStream
}

type adaCoreServiceBuildWithMarkdownClient struct {
	grpc.ClientStream
}

func (x *adaCoreServiceBuildWithMarkdownClient) Send(m *MarkdownStream) error {
	return x.ClientStream.SendMsg(m)
}

func (x *adaCoreServiceBuildWithMarkdownClient) CloseAndRecv() (*ReplyMarkdown, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReplyMarkdown)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AdaCoreServiceServer is the server API for AdaCoreService service.
type AdaCoreServiceServer interface {
	// buildWithMarkdown - build with markdown
	BuildWithMarkdown(AdaCoreService_BuildWithMarkdownServer) error
}

func RegisterAdaCoreServiceServer(s *grpc.Server, srv AdaCoreServiceServer) {
	s.RegisterService(&_AdaCoreService_serviceDesc, srv)
}

func _AdaCoreService_BuildWithMarkdown_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdaCoreServiceServer).BuildWithMarkdown(&adaCoreServiceBuildWithMarkdownServer{stream})
}

type AdaCoreService_BuildWithMarkdownServer interface {
	SendAndClose(*ReplyMarkdown) error
	Recv() (*MarkdownStream, error)
	grpc.ServerStream
}

type adaCoreServiceBuildWithMarkdownServer struct {
	grpc.ServerStream
}

func (x *adaCoreServiceBuildWithMarkdownServer) SendAndClose(m *ReplyMarkdown) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adaCoreServiceBuildWithMarkdownServer) Recv() (*MarkdownStream, error) {
	m := new(MarkdownStream)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AdaCoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "adacorepb.AdaCoreService",
	HandlerType: (*AdaCoreServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "buildWithMarkdown",
			Handler:       _AdaCoreService_BuildWithMarkdown_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "adacore.proto",
}

func init() { proto.RegisterFile("adacore.proto", fileDescriptor_adacore_329eb421bb8e5878) }

var fileDescriptor_adacore_329eb421bb8e5878 = []byte{
	// 395 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x4d, 0x6f, 0x9b, 0x40,
	0x10, 0x2d, 0xd8, 0xb8, 0xf5, 0x80, 0xdd, 0x76, 0xd5, 0xaa, 0x5b, 0xab, 0x07, 0x8a, 0x2a, 0x95,
	0x13, 0x07, 0xf7, 0x52, 0x55, 0xed, 0xa1, 0x5f, 0x6a, 0x0f, 0x4e, 0x0e, 0xf8, 0x90, 0x5b, 0xa4,
	0x05, 0x56, 0x01, 0x19, 0x58, 0x34, 0x5e, 0x1c, 0xf1, 0x9f, 0x92, 0xff, 0x91, 0x9f, 0x94, 0x63,
	0xb4, 0x8b, 0x21, 0x10, 0x25, 0xb7, 0x79, 0x33, 0xef, 0xcd, 0x9b, 0xd9, 0x59, 0x58, 0xb0, 0x84,
	0xc5, 0x02, 0x79, 0x50, 0xa1, 0x90, 0x82, 0xcc, 0x8f, 0xb0, 0x8a, 0xbc, 0x5b, 0x03, 0x9c, 0x13,
	0x86, 0xbb, 0x44, 0x5c, 0x96, 0x7f, 0x98, 0x64, 0x84, 0xc2, 0xf3, 0xbd, 0x44, 0x15, 0x52, 0xc3,
	0x35, 0xfc, 0x79, 0xd8, 0x41, 0xf2, 0x0f, 0x20, 0xca, 0x4a, 0x86, 0x8d, 0x2e, 0x9a, 0xee, 0xc4,
	0xb7, 0xd7, 0x9f, 0x83, 0xbe, 0x55, 0x30, 0x6c, 0x13, 0xfc, 0xea, 0x99, 0x7f, 0x4b, 0x89, 0x4d,
	0x38, 0x90, 0x12, 0x0f, 0x1c, 0xc9, 0x8b, 0x2a, 0x67, 0x92, 0x9f, 0xb2, 0x82, 0x53, 0xd0, 0x3e,
	0xa3, 0xdc, 0x90, 0xa3, 0xed, 0xec, 0x31, 0x47, 0xe5, 0x56, 0x3f, 0xe0, 0xe5, 0x03, 0x1b, 0xf2,
	0x0a, 0x26, 0x3b, 0xde, 0x1c, 0x27, 0x57, 0x21, 0x79, 0x03, 0xd6, 0x81, 0xe5, 0x35, 0xa7, 0xa6,
	0x6b, 0xf8, 0x4e, 0xd8, 0x82, 0x6f, 0xe6, 0x57, 0xc3, 0xbb, 0x36, 0x61, 0xd9, 0xcd, 0xbc, 0x95,
	0xc8, 0x59, 0x41, 0x5c, 0xb0, 0xa5, 0x90, 0x2c, 0xdf, 0xf0, 0xf2, 0x42, 0xa6, 0xba, 0x8d, 0x15,
	0x0e, 0x53, 0x64, 0x05, 0x2f, 0xe2, 0x1a, 0xb7, 0x92, 0xa1, 0xd4, 0x1d, 0xad, 0xb0, 0xc7, 0xe4,
	0x03, 0xcc, 0xe3, 0x1a, 0x8f, 0xda, 0x89, 0x2e, 0xde, 0x27, 0x94, 0x32, 0x65, 0xfb, 0x54, 0x6f,
	0x33, 0xd5, 0xf3, 0xf5, 0x98, 0x7c, 0x82, 0x85, 0x36, 0xf9, 0xdf, 0x11, 0x2c, 0x4d, 0x18, 0x27,
	0x09, 0x81, 0x69, 0xa2, 0x8a, 0x33, 0xbd, 0x89, 0x8e, 0xd5, 0x7a, 0x1c, 0x51, 0x20, 0x4d, 0xb4,
	0xa2, 0x05, 0xe4, 0x3b, 0x38, 0xc5, 0xe0, 0x1a, 0xf4, 0x46, 0x6d, 0x62, 0xaf, 0xdf, 0x3d, 0x71,
	0xad, 0x70, 0xc4, 0x26, 0x6f, 0xc1, 0x92, 0x62, 0xc7, 0x4b, 0x7a, 0x65, 0xb6, 0x4d, 0x35, 0xf2,
	0x3e, 0xc2, 0x22, 0xe4, 0x55, 0xde, 0x74, 0x4a, 0xf5, 0xd8, 0x35, 0xe6, 0xdd, 0x63, 0xd7, 0x98,
	0xaf, 0xcf, 0x61, 0xf9, 0x33, 0x61, 0xbf, 0x05, 0xf2, 0x2d, 0xc7, 0x43, 0x16, 0x73, 0xb2, 0x81,
	0xd7, 0x51, 0x9d, 0xe5, 0xc9, 0x59, 0x26, 0xd3, 0x5e, 0xf8, 0xfe, 0x91, 0x39, 0xda, 0x0b, 0xac,
	0xe8, 0xa0, 0x34, 0x72, 0xf3, 0x9e, 0xf9, 0x46, 0x34, 0xd3, 0xff, 0xf7, 0xcb, 0x5d, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x8f, 0x2e, 0xd1, 0x4d, 0xd0, 0x02, 0x00, 0x00,
}
